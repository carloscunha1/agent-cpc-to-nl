# Conversor de SentenÃ§as - LÃ³gica Proposicional

## Link para testes:
https://agent-cpc-to-79am665t4-carlos-cunhas-projects.vercel.app/

## URL do vÃ­deo de utilizaÃ§Ã£o:

https://youtu.be/Z39_0DXu4co

## ğŸ“‹ Escopo do Projeto

Este projeto Ã© um conversor bidirecional entre **linguagem natural** e **cÃ¡lculo proposicional clÃ¡ssico**, desenvolvido como parte da disciplina de LÃ³gica para ComputaÃ§Ã£o da FACEF.

## ğŸ¯ Funcionalidades Principais

1. ConversÃ£o de Linguagem Natural para LÃ³gica
	- Recebe uma sentenÃ§a em portuguÃªs
	- Converte para fÃ³rmula do cÃ¡lculo proposicional clÃ¡ssico
	- Utiliza sÃ­mbolos: âˆ§ (e), âˆ¨ (ou), Â¬ (negaÃ§Ã£o), â†’ (implica), â†” (se e somente se)
	- Atribui letras proposicionais (p, q, r, ...)

2. ConversÃ£o de LÃ³gica para Linguagem Natural
	- Recebe uma fÃ³rmula lÃ³gica 
	- Converte para uma sentenÃ§a clara em portuguÃªs

3. Interface Web
	- Frontend em HTML/CSS/JavaScript
	- AlternÃ¢ncia entre os modos de conversÃ£o
	- ExibiÃ§Ã£o do resultado e mapeamento das proposiÃ§Ãµes

## ğŸ—ï¸ Arquitetura (resumo)

- Backend: FastAPI + integraÃ§Ã£o com GenKit / Google Gemini para apoio na anÃ¡lise e conversÃ£o.
- Frontend: HTML/CSS/JS servidos por `index.html`.

Arquivos principais:

```
frontend/index.html       # Interface web
backend/main.py           # Servidor FastAPI com endpoints
README.MD                 # DocumentaÃ§Ã£o (este arquivo)
```

## ğŸ”Œ Endpoints da API

| MÃ©todo | Endpoint | DescriÃ§Ã£o |
|--------|----------|-----------|
| POST | `/convert/nl-to-logic` | Converte linguagem natural para fÃ³rmula lÃ³gica |
| POST | `/convert/logic-to-nl` | Converte fÃ³rmula lÃ³gica para linguagem natural |
| GET  | `/`                    | InformaÃ§Ãµes da API |

## ğŸš€ Como Usar Localmente (rÃ¡pido)

Instalar dependÃªncias e executar o backend (ver `backend/requirements.txt`):

```bash
cd backend
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
python3 main.py

# Em outro terminal (servir frontend):
cd ../frontend
python3 -m http.server 8080
```

Acesse `http://localhost:8080`.

## ğŸ“ EstratÃ©gia de traduÃ§Ã£o (regras, mapeamento e uso de LLMs)



### 1) Objetivo e contrato
- Entrada: frase(s) em portuguÃªs ou uma fÃ³rmula proposicional simbÃ³lica.
- SaÃ­da: fÃ³rmula do cÃ¡lculo proposicional com letras proposicionais (p, q, r, ...) e/ou uma sentenÃ§a em portuguÃªs que explique o mapeamento.
- Erro/limite: O sistema pressupÃµe domÃ­nio proposicional (sem quantificadores) e nÃ£o resolve ambiguidade pragmÃ¡tica sem contexto adicional.

### 2) Regras e mapeamento (NL â†’ LÃ³gica)

- IdentificaÃ§Ã£o de predicados proposicionais: frases ou oraÃ§Ãµes independentes viram proposiÃ§Ãµes atÃ´micas. Ex.: "chove" â†’ p; "a rua fica molhada" â†’ q.
- Conectivos:
  - "e", "alÃ©m disso", "mas" â†’ âˆ§ (conjunÃ§Ã£o)
  - "ou" (disjunÃ§Ã£o inclusiva) â†’ âˆ¨
  - "nÃ£o", "nÃ£o Ã© verdade que" â†’ Â¬ (negaÃ§Ã£o) â€” atenÃ§Ã£o ao alcance da negaÃ§Ã£o
  - "se... entÃ£o", "caso" â†’ â†’ (implicaÃ§Ã£o). InterpretaÃ§Ã£o: condicional material por padrÃ£o
  - "se e somente se", "somente se e se" â†’ â†” (bicondicional)

- PrecedÃªncia e parÃªnteses: aplica-se a precedÃªncia lÃ³gica padrÃ£o (Â¬ > âˆ§ > âˆ¨ > â†’ > â†”) e insere parÃªnteses explicitamente quando necessÃ¡rio.
- VariÃ¡veis proposicionais: atribuÃ­mos letras p, q, r... mantendo um dicionÃ¡rio que associa cada frase atÃ´mica Ã  letra usada e retornamos esse mapeamento ao usuÃ¡rio.

### 3) Regras e mapeamento (LÃ³gica â†’ NL)

- Cada operador Ã© verbalizado de forma natural: âˆ§ â†’ "e", âˆ¨ â†’ "ou", Â¬ â†’ "nÃ£o", â†’ â†’ "se... entÃ£o...", â†” â†’ "se e somente se".
- Mantemos o mapeamento das letras para as descriÃ§Ãµes fornecidas (quando existirem) para produzir sentenÃ§as legÃ­veis.

### 4) Uso da LLM (Google Gemini) e pipeline hÃ­brido

Abordagem hÃ­brida: LLM + regras simbÃ³licas.

- Etapa A (prÃ©-processamento simbÃ³lico): normalizaÃ§Ã£o do texto (remoÃ§Ã£o de ruÃ­do, tokenizaÃ§Ã£o), detecÃ§Ã£o de possÃ­veis clÃ¡usulas atÃ´micas usando regex/heurÃ­sticas.
- Etapa B (LLM para interpretaÃ§Ã£o): a LLM Ã© consultada com um prompt few-shot para sugerir uma estrutura lÃ³gica e possÃ­veis mapeamentos. Usamos temperatura baixa para respostas determinÃ­sticas.
- Etapa C (verificaÃ§Ã£o simbÃ³lica): parse do resultado sugerido pela LLM com um parser simples; validaÃ§Ã£o de sintaxe, aplicaÃ§Ã£o de precedÃªncia e consistÃªncia do mapeamento de variÃ¡veis.
- Etapa D (correÃ§Ã£o/fallback): se o output nÃ£o for bem formado ou houver inconsistÃªncias, aplicam-se regras heurÃ­sticas (por exemplo, isolar clÃ¡usulas por conjunÃ§Ãµes/condicionais e reprocessar) ou re-chamar a LLM com um prompt ajustado.


## ğŸ§ª Exemplos de input/output com anÃ¡lise (acertos e erros)

1) Simples â€” condicional direto (acerto)

- Entrada (NL): "Se chove, entÃ£o a rua fica molhada"
- SaÃ­da esperada (LÃ³gica): p â†’ q
- Mapeamento retornado: p = "chove", q = "a rua fica molhada"

AnÃ¡lise: Frase direta, sujeito e consequÃªncia explÃ­citos. O sistema normalmente acerta, pois estrutura sintÃ¡tica Ã© clara e corresponde ao padrÃ£o "Se A, entÃ£o B".

2) ConjunÃ§Ã£o com negaÃ§Ã£o (acerto com atenÃ§Ã£o ao escopo)

- Entrada (NL): "NÃ£o chove e a rua estÃ¡ molhada"
- SaÃ­da possÃ­vel (LÃ³gica): Â¬p âˆ§ q
- Mapeamento: p = "chove", q = "a rua estÃ¡ molhada"

AnÃ¡lise: O escopo da negaÃ§Ã£o Ã© "chove" â€” aqui o parser heurÃ­stico lida bem. Risco: em sentenÃ§as como "NÃ£o (chove e a rua estÃ¡ molhada)" o resultado muda; por isso, o sistema sempre tenta inserir parÃªnteses para deixar o escopo explÃ­cito.

3) Ambiguidade de "ou" (erro comum)

- Entrada (NL): "VocÃª pode beber chÃ¡ ou cafÃ©"
- SaÃ­da (LÃ³gica) (geral): p âˆ¨ q

AnÃ¡lise: Em linguagem natural, "ou" pode ser exclusivo (XOR) ou inclusivo (OR). O sistema assume disjunÃ§Ã£o inclusiva (âˆ¨). Erro: quando o domÃ­nio exige exclusividade. MitigaÃ§Ã£o: solicitar esclarecimento ao usuÃ¡rio ou usar heurÃ­sticas baseadas em verbos/modais.

4) Antecedente composto implÃ­cito (erro de segmentaÃ§Ã£o)

- Entrada (NL): "Se chove e tem vento, a festa Ã© cancelada"
- SaÃ­da correta: (p âˆ§ r) â†’ q  (p = "chove", r = "tem vento", q = "a festa Ã© cancelada")

PossÃ­vel erro: dividir em duas implicaÃ§Ãµes p â†’ q âˆ§ r â†’ q se a segmentaÃ§Ã£o de clÃ¡usulas nÃ£o for feita corretamente.

MitigaÃ§Ã£o: prÃ©-processamento que detecta conjunÃ§Ãµes no antecedente e agrupa como conjunÃ§Ã£o Ãºnica.

5) Frases com pronomes e implicatura (difÃ­cil para LLMs simples)

- Entrada (NL): "Se JoÃ£o chega atrasado, ele perde a prova"
- SaÃ­da: p â†’ q

Desafio: resolver que "ele" refere-se a "JoÃ£o" â€” normalmente o sistema (com LLM) resolve por co-referÃªncia, mas heurÃ­sticas simples podem falhar.

6) Bicondicional natural (sucesso quando explÃ­cito)

- Entrada (NL): "VocÃª tem ingresso se e somente se pagou"
- SaÃ­da: p â†” q

AnÃ¡lise: Quando expressÃµes como "se e somente se" aparecem explicitamente, o sistema mapeia corretamente para â†”. Problemas surgem quando a linguagem natural usa locuÃ§Ãµes indiretas.

## Fluxo da aplicaÃ§Ã£o

![alt text](/assets/fluxo.png)

## PrÃ³ximos passos e melhorias sugeridas

- Implementar um mÃ³dulo leve de co-referÃªncia (ou usar recurso de LLM com prompt especÃ­fico) para reduzir erros com pronomes.
- Fornecer uma interface de esclarecimento (quando o sistema detecta baixa confianÃ§a, perguntar ao usuÃ¡rio se "ou" Ã© exclusivo, qual o escopo da negaÃ§Ã£o, etc.).
- Adicionar testes unitÃ¡rios para o parser e para os exemplos mais comuns.

## ğŸ› ï¸ Tecnologias Utilizadas

- Python 3
- FastAPI
- GenKit (camada de integraÃ§Ã£o com Google Gemini)
- HTML5/CSS3/JavaScript
- Pydantic (validaÃ§Ã£o de dados)

## ğŸ“š Disciplina
LÃ³gica para ComputaÃ§Ã£o - Uni-FACEF


